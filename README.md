# In-Kernel-Per-Process-Sandbox
# LLVM COMPILER PASSES
Submitted By : AMIT APPANNA TALAWAR.    
SR-NO : 24036.  
The Tool was built out of tree on LLVM version 18.1.3.

Please download and compile from source the required version to test the tool.
The tool file consists of two passes (Currently has only Instrumentation pass, work on Libc Call Graph is not complete).
1. Libc Call Graph Pass
2. DUMMY SYSTEM CALL Instrumentation

# Dummy System Call Instrumentation

Enter into the Out of Tree Pass Folder (submitted file) and execute the following commands to generate the shared library pass file.

```bash
cd path/to/the/pass/folder
export LLVM_DIR=<installation/dir/of/llvm18> #installation directory of llvm 18
mkdir build
cd build
export CXX=/usr/bin/clang++-18
export CC=/usr/bin/clang-18
cmake -DLT_LLVM_INSTALL_DIR=<installation/dir/of/llvm18> </path/to/pass/folder>
make
```
We also have to generate the lists of LIBC Function calls, The pass folder has a Python Script to extract all the LIBC function calls of a particular version (which can be changed in the file) and also attaches them with a Unique Identifier for Dummy Sys Call.
```python
cd path/to/the/pass/folder
#Run the python file to generate the txt file.
```

## Compiling MBED-TLS

Before we can test this pass, Install MBED-TLS from source (Preferably in a different directory dont clone it into the Pass Folder).
```bash
git clone https://github.com/Mbed-TLS/mbedtls.git
cd mbedtls
git submodule update --init --recursive
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_PROGRAMS=ON ..
```
Now that we have the MBEDTLS source code, we can compile the files in the program folder using CLANG to get the .ll files, which are essentially inputs for our PASS. We can use the bash script generate_ll_files.sh which will compile all the .c files and place them into a folder called mbed_ll_files in our current working directory.
```bash
cd path/to/the/pass/folder
#Set the input and output folder directories in generate_ll_files.sh accordingly
chmod +x generate_ll_files.sh
./generate_ll_files.sh
```

You might encounter some errors while compiling some files that is because some .c files are auto-generated by mbed-tls and they lack header files, just ignore those errors.


## Testing
Now that we have all the prerequisites handled, we have only one bash script to run which will handle the opt command along with our pass plugin for dummy sys call instrumentation and write the instrumented .ll files to our parent folder inside a folder called mbedtls_instrumented.

```bash
#Set the input and output folder directories in mbedtls_dummysyscall.sh accordingly
chmod +x mbedtls_dummysyscall.sh
./mbedtls_dummysyscall.sh
```
You can verify the instrumentation by searching for a LIBC function call in one of these output files, you will encounter a inline ASM system call for DUMMYSYSCALL with an integer input i.e. the Unique Identifier we inserted during extracting process of Libc Function Calls.

```bash
call void asm sideeffect "movq $0, %rax; movq $1, %rdi; syscall", "r,r"(i64 100, i64 11169)
```
Note that the syscall number 100 that we are passing is a dummy identifier of the syscall we are injecting. Can also verify the instrumentation by generating the executable and using objdump to see the instructions instrumented.


<!-- export LLVM_DIR=~/llvm18/build #installation directory of llvm 18
mkdir build
cd build

export CXX=/usr/bin/clang++-18
export CC=/usr/bin/clang-18

cmake -DLT_LLVM_INSTALL_DIR=~/llvm18/build ~/Final_Passes
make


$LLVM_DIR/bin/clang -O0 -emit-llvm -S ../input_files/trial_input.c -o trial_input.ll
$LLVM_DIR/bin/opt -load-pass-plugin ./lib/libDummySysCall.so --passes="inject-dummy-sys-call" -S /home/amit-talawar/mbedtls/ll_files/crypt_and_hash.ll -o output.ll

$LLVM_DIR/bin/opt -load-pass-plugin ./lib/libLibraryCallGraph.so --passes="library-call-graph" -S /home/amit-talawar/mbedtls/ll_files/crypt_and_hash.ll -o output.ll

$LLVM_DIR/bin/clang -emit-llvm -c ~/Semester\ 1/Computer\ System\ Security/Project/Final_Passes/input_files/trial_input.c -o trial_input.bc~/Semester\ 1/Computer\ System\ Security/Project/Final_Passes/

$LLVM_DIR/bin/opt -load-pass-plugin ~/Semester\ 1/Computer\ System\ Security/Project/Final_Passes/build/lib/libStaticCallCounter.so -passes="print<static-cc>" -disable-output trial_input.bc -->
# CSS Project Part II
## Compiling the kernel and booting it in Virtual Box
 - Downloading the kernel
 ```bash
 git clone https://github.com/torvalds/linux.git
 ```
 - Make a Build Folder
 ```bash
 mkdir build
 make O=../build x86_64_defconfig
 make O=../build makeconfig
 # Note make changes to BPF subsystem here.
 make O=../build -j$(nproc)
 ```
 - Once you have the bzImage in the arch/x86_64/boot folder, we have to copy it into the VM. Execute the following command in the Virtual Machine.
 ```bash
 scp hostname@hostip:path/to/bzImage ./
 ```
 - I was running server ubuntu 24.04.01 on the VM you can choose any appropriate versions.
 - Placing the bzImage in the boot folder and generating necessary dependencies
 ```bash
 sudo cp bzImage /boot/vmlinuz-custom
 sudo update-initramfs -c -k all
 sudo update-grub
 sudo reboot now
 ```
 - Now you will booting into the kernel image we compiled, or else make sure you press ESC and choose the right kernel to boot into. This is the baseline of how I have compiled the kernel in the LAB pc and copied the bzImage into Virtual Machine after the changes I have made to the kernel with adding the *Dummy Syscall* definition.

## Dummy Syscall Implementation

- Writing the code base
```bash
  cd path/to/the/linux/kernel
  mkdir dummy
  touch dummysc.c
  touch Makefile
```
- *dummysc.c* will have the definition of the system call, the Makefile will facilitate in compiling the modified kernel
- We have to add a simple line in the Makefile at this folder tree
```bash 
obj-y := dummysc.o
```
- Updating the kernel Makefile
```bash
cd ..
nano Makefile
#add /dummy at the line "core-y"
```
- Add the Dummy Syscall to syscall table
```bash
cd arch/x86/entry/syscalls/
nano syscall_64.tbl
# Add the following line: 548   64   dummy    sys_dummy
```
- Add the header info in syscall.h 
```bash
cd include/linux/
nano syscalls.h
# Add the following line at the end of the file : asmlinkage long sys_dummy(int arg)
```
- Compile the modified kernel
```bash
make O=../build -j$(nproc)
```
- Note that we have to follow the same steps described in the initial part of the readme and copy the modified kernel bzImage into the VM and reboot after updating necessary components.
- We can test the working of the modified kernel by running a file that has syscalls to dummy sys call, the code that has been passed through Part 1 LLVM dummysyscall pass and check the dmesg to see the log and verify the implementation.



## Kernel Monitor
- Writing the code base
```bash
touch lib_monitor.py
# Install necessary bpftools
# The contents of the file have been submitted in the zip file.
chmod +x lib_monitor.py
sudo python3 lib_monitor.py &
# Now run the .out program to see the ebpf monitor the code
./program.out
```
